#!/bin/bash
# Flags
    # Source 1: https://stackoverflow.com/a/7948533/31298396
    # Source 2: https://unix.stackexchange.com/a/801193/779203

# usage source: https://stackoverflow.com/a/40580415/31298396
usage () {
cat <<HELP_USAGE
# Actual contents here to be written after the rest of the script has been finalised.
usage: $(basename "$0") [-a] -f <file>
        -a  All the instances.
        -f  File to write all the log lines
HELP_USAGE
}

textree_options=$(
    getopt -o i:I:O:n:N:adlfxL:P\
              --long "\
                      namestyle:,\
                      Name:,\
                      ignore:,ignore-add:,ignore-also:,\
                      Ignore:,Ignore-only:,\
                      wsl,wsl,\
                      cygwin,Cygwin,cygwin,\
                      debug,
                     "\
              -n 'textree' -- "$@"
) || usage

eval "set -- $textree_options"

# Default values
ignore_default="FileTrees|_minted|ignore_this*|*.log|*.out|*.tmp|*.synctex(busy)|*.synctex.gz|*.listing|*.pre|*.aux|*.auxlock|*.toc|*.config.minted"
ignore_also=
wsl=false
cygwin=false
debug=false
namestyle=name
tree_options=
    # Print out an XML representation of the tree.
    tree_options+=' -X'

while true; do
  case "$1" in
    -n | --namestyle ) namestyle="$2"; shift 2 ;;
    -N | --Name ) NAME="$2"; shift 2 ;;
    -i | --ignore | --ignore-add | --ignore-also ) ignore_also="$2"; shift 2 ;;
    -I | --Ignore | --Ignore-only ) ignore_only="$2"; shift 2 ;;
    -O ) output_to="$2"; shift 2 ;;
    --wsl | --WSL ) wsl=true; shift;;
    --cygwin | --Cygwin | --CYGWIN ) cygwin=true; shift;;
    -a ) tree_options+=' -a'; shift;;
    -d ) tree_options+=' -d'; shift;;
    -l ) tree_options+=' -l'; shift;;
    -f ) tree_options+=' -f'; shift;;
    -x ) tree_options+=' -x'; shift;;
    -L ) tree_options+=" -L $2"; shift 2 ;;
    -P ) tree_options+=' -P'; shift;;
    --debug ) debug=true; printf "\n =============\n debug mode on\n =============\n"; shift;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

# If $ignore_only is undefined, set $ignore = $ignore_default|$ignore_also. Or if, simultaneously, $ignore_also is empty, set $ignore = $ignore_default (no vertical bar).
if [ -z ${ignore_only+x} ]; \
  then \
    if [ -z "${ignore_also}" ]; \
      then ignore="$ignore_default"; \
      else ignore="$ignore_default|$ignore_also";\
    fi \
  # If $ignore_only is defined, set $ignore = $ignore_only
  else ignore="$ignore_only"; \
fi

# If $output_to is empty, set $output_to = "filetree.tmp". Otherwise, use its current value.
if [ -z "${output_to}" ]; \
    then output_to="filetree.tmp";\
fi

path_processing () {
    if [ "$wsl" = true ] ; then
        wslpath -u "$1" 
    fi
    if [ "$cygwin" = true ] ; then
        cygpath -u "$1" 
    fi
    if [[ "$wsl" == false && "$cygwin" == false ]]; then
        cat <<< "$1"
    fi
}

# Processing paths
    # Target directory to textree
        # If $1 is unset, set tree_target as ""./". Otherwise, process its path --- apply the function path_processing on it.
        if [ -z ${1+x} ]; then
            tree_target='./'
        else
            tree_target="$(path_processing "$1")"
        fi
    # File to send the output of textree to
    output_to="$(path_processing "$output_to")"

# Process the name to set for the target directory, from the $namestyle set.
case $namestyle in
    # Case 1: $NAME = name: set $directory_name to be the name of the target directory, instead of $1.
        # Source: https://discord.com/channels/846677253290983444/846681015011115018/1425821608878280794
    name)
        directory_name=$(basename "$(realpath "$tree_target")")
    ;;
    # Case 2: $NAME = realpath: set $directory_name to be realpath $1.
    realpath) 
        directory_name=$(realpath "$tree_target")
    ;;
    # Case 3: $NAME = raw: set $directory_name to be $1.
    raw) 
        directory_name=$tree_target
    ;;
    *) echo "-n namestyle or --name namestyle recieved an invalid namestyle of $namestyle" || exit ;;
esac

# If there is a provided NAME, use it as the name of the target directory to typeset.
if [ ! -z ${NAME+x} ]; then
    directory_name=$NAME
fi

# Escape the replacement string
    # Source: https://stackoverflow.com/a/29613573/31298396
directory_name_escaped=$(sed 's/[&/\]/\\&/g' <<<"$directory_name")

# Escape $1 so it is parsed literally/verbatim in sed's regex.
    # Source: https://stackoverflow.com/a/29613573/31298396
directory_path_escaped=$(sed 's/[^^]/[&]/g; s/\^/\\^/g' <<< "$tree_target") # escape it.

# Function symlink_type that tells forest what picture (symlink-to-[folder|file]) to use to decorate the symlink.
symlink_type () {
    if [[ -d $1 ]]; then
        printf 'symlink-to-folder'
    elif [[ -f $1 ]]; then
        printf 'symlink-to-file'
    else
        echo "$1 is an invalid path."
        exit 1
    fi
}

`# Generate the file tree for the directory $1` \
    `# Source: https://tex.stackexchange.com/q/515582/383565` \
tree \
    `# Exclude the folder "some_folder", "another_folder", all files starting with "ignore_this", and all files with extension .log, .out, etc` \
    -I "$ignore" \
    `# Turn off file/directory count at end of tree listing.` \
    --noreport \
    `# Additional options to pass to tree` \
    $tree_options \
    `# The directory $1` \
    "$tree_target" \
`# Pass the output of tree to the input of sed` \
| \
`# Text manipulation, for us to convert the XML output format to a TikZ forest one. The option "-e [command]" adds [command] to the list of commands that sed executes. ` \
    `# syntax of the s command: 's/regexp/replacement/flags'` \
sed \
    `# Replace "<directory name=".">" by "<directory name=$directory_name>"` \
    -e "s/<directory name=\".\">/<directory name=\"$directory_name_escaped\">/" \
    `# Replace "<directory name="$1">" by "<directory name=$directory_name_escaped>"` \
    -e "s/<directory name=\"$directory_path_escaped\">/<directory name=\"$directory_name_escaped\">/" \
    `# LaTeX-escape backslashes` \
    -e 's/\\/\\textbackslash/g' \
    `# Replace curly braces in directory/file names by their LaTeX-escaped variants.` \
    -e 's/{/\\{/g' \
    -e 's/}/\\}/g' \
    `# (cont.) LaTeX-escape backslashes` \
    -e 's/\\textbackslash/{\\textbackslash}/g' \
    `# Replace "<tree>" by "\begin{forest}for tree={folder,grow\'=0}/"` \
    -e "s/<tree>/\\\begin{forest}\n file tree,/" \
    `# Replace "</tree>" by "\end{forest}"` \
    -e 's/<\/tree>/\\end{forest}/' \
    `# Replace " target=" by " \symlinkrightarrow"` \
    -e 's/\" target=\"/\" \\symlinkrightarrow \"/' \
    `# Replace "<directory name=" and "<file name=" by an opening square bracket [ (escaped to make it an actual square bracket)` \
    -e 's/<directory name=\|<file name=\|<link name=/[/' \
    `# Replaces "anything that does not contain a double-quotation mark by "` \
            `# backslash \: escapes the character following it.` \
        `# Regex operators` \
            `# \(...\): a capturing group. This simply capture its contents ... as one unit. Think of how curly braces {...} work in LaTeX.` \
            `# \n: contents of the nth capturing group (...).` \
        `# Wildcard operators` \
            `# [...]: a matching list. A character is matched iff it is contained in [...].` \
            `# [^...]: a nonmatching list. A character is matched iff it is not contained in [^...].` \
            `# <string>*: any string that starts with <string>` \
        `# Breakdown` \
            `# \": a double-quote character` \
            `# [^"]: any character that is not a double-quote character` \
            `# [^"]*: any string that does not start with a double-quote character` \
            `# \([^"]*\): same as before` \
            `# \"\([^"]*\)\">: any <string> of the form <string> = "<substring>">, where <substring> (which is just \1) does not contain any double-quote character. ` \
            `# "\([^"]*\)\">/\1: replace any <string> --- of the form <string> = "<substring>">>, where <substring> (which is just \1) does not contain any double-quote character --- by \1 = <substring>` \
            `# "\([^"]*\)\">/\{\1\}: replace any <string> --- of the form <string> = "<substring>">>, where <substring> (which is just \1) does not contain any double-quote character --- by {\1} = {<substring>}` \
                `# Replace "<name>" by "{<name>}" for robustness --- this allows square brackets to be used in directory/file names.` \
    -e 's/\"\([^"]*\)\"[> ]/{\1}/g' \
    `# Replace "</directory>" by a closing square bracket "]"` \
    -e 's/<\/directory>/]/' \
    `# Replace "</file>" by ", file]"` \
    -e 's/<\/file>/, file]/' \
    `# Replace "</link>" by ", symlink-to-[folder|file]` \
        `# The following single commented line doesn't do the trick. Why? See https://superuser.com/a/1496362: "$(...) runs BEFORE sed is launched".` \
        `# -e 's/\\\symlinkrightarrow {\(.*\)}<\/link>/\\\symlinkrightarrow {\1}, symlink_type "\1"]/'` \
        `# This actually works:` \
        `# Source: https://superuser.com/a/1496401` \
        -e "/\\\symlinkrightarrow {\(.*\)}<\/link>/ {
            s/'/'\"'\"'/g
            s/\\\symlinkrightarrow {\(.*\)}<\/link>/\\\symlinkrightarrow {\1}, '\"\$(symlink_type '\1')\"']/g
            s/.*/printf '%s' '\0'/e
        }" \
    `# Further brace processing: make one set of braces wrap the full name of symlinks to be typeset.` \
    -e 's/}\\symlinkrightarrow {/ \\symlinkrightarrow /' \
    `# Delete any string that starts with "<?xml version"` \
    -e '/^<?xml version/d' \
    `# Character replacement to ensure the correct file names are generated.` \
    `# Replace &quot; (which is produced by passing " into sed) by an actual double-quotation mark.` \
    -e 's/&quot;/\"/g' \
    `# Replace characters by their escaped LaTeX counterparts, where necessary.` \
        `# {} and \ have been escaped earlier (for ordering requirements).` \
    -e 's/\$/\\$/g' \
    -e 's/\&amp;/&/g' \
    -e 's/#/\\#/g' \
    -e 's/[|]/{\\textbar}/g' \
    -e 's/_/\\_/g' \
    -e 's/\^/{\\textasciicircum}/g' \
    -e 's/@/\\@/g' \
    -e 's/%/\\%/g' \
    -e 's/\&lt;/{\\textlangle}/g' \
    -e 's/\&gt;/{\\textrangle}/g' \
    -e 's/~/\\textasciitilde/g' \
    -e 's/+/\\(+\\)/g' \
    -e 's/=/\\(=\\)/g' \
    `# Pass the output of sed to the input of install` \
    | \
    `# Create the directory FileTrees and the file tree_$2. if necessary. Then, write the output of sed to tree_$2.` \
        `# Source: https://stackoverflow.com/a/21053077/31298396` \
    install -D /dev/stdin "$output_to"


# --debug: show processed paths
if [ $debug = true ]; then
    # Bolding text
    # Source: https://stackoverflow.com/a/2924755/31298396
    textbf=$(tput bold)
    textrm=$(tput sgr0)
    ulstart=$(tput smul)
    ulend=$(tput rmul)
    textreset=$(tput init)
    textblue=$(tput setaf 4)
    textgreen=$(tput setaf 2)
echo -ne \
"\
${textblue}${textbf}BOOL${textrm}
${textblue}NAME:$NAME
${textblue}namestyle:$namestyle
${textblue}ignore:$ignore
${textblue}ignore_also:$ignore_also
${textblue}ignore_only:$ignore_only
${textblue}wsl:$wsl
${textblue}cygwin:$cygwin
${textblue}debug:$debug
${textgreen}${textbf}Strings${textrm}
${textgreen}tree_target:$tree_target:$(realpath "$tree_target")
${textgreen}directory_name:$directory_name
${textgreen}directory_name_escaped:$directory_name_escaped
${textgreen}directory_path_escaped:$directory_path_escaped\
${textreset}\
"\
 | \
column -t -s ":" -C "name=${ulstart}${textbf}VARIABLE" -C "name=VALUE${textrm}${ulend},wrap" -C "name=${ulstart}Remarks${ulend},wrap"
fi
