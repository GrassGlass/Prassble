#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;

# Option processing
    my $data   = "file.dat";
    my $length = 24;
    my $debug;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "debug"  => \$debug)   # flag
    or die("Error in command line arguments\n");

# Argument processing
    my $textree_target;
    if (@ARGV == 0)
    {
        $textree_target = "\".\"";
    }
    foreach my $arg (@ARGV) {
        if ($arg eq "")
        {
            die("Error: an empty target directory has been provided");
        }
        $textree_target .= "\"$arg\" "
    } 

# Subroutines
    # if_debugging
        # Help obtained from: https://discord.com/channels/846677253290983444/947413601688358935/1440347953457004574 (private discord server)
        sub if_debugging {
            my ($code) = @_;

            if (@_ > 1) {
                die "More than one argument has been passed to the subroutine 'if_debugging'.\n";
            }
        
            return unless defined $debug && $debug == 1;

            $code->();
        }

# Use the 'diagnostics' module if the flag '--debugging' is used.
    if_debugging( sub { eval {
        require diagnostics;
            diagnostics->import();
            1; 
    } } );

`tree -f -X "$textree_target" | install -D /dev/stdin "./textrees/textree_1"`;

# Source: https://stackoverflow.com/a/33245306/31298396
sub rewrite_file {
    my $file = shift;

    # You can still read from $in after the unlink, the underlying
    # data in $file will remain until the filehandle is closed.
    # The unlink ensures $in and $out will point at different data.
    open(my $in, "<", $file);
    unlink($file);

    # This creates a new file with the same name but points at
    # different data.
    open(my $out, ">", $file);

    return($in, $out);
}

my($in, $out) = rewrite_file("./textrees/textree_1");

my $link_target_type;
my $file_type;
my $dir_count = 0;
my $file_count = 0;
my %symlink_target_count_by_types = ( 
    'total'                   => 0,
    'nonexistent'             => 0,
    'dir'                     => 0, 
    'plain-file'              => 0, 
    'symlink'                 => 0, 
    'pipe'                    => 0, 
    'socket'                  => 0, 
    'block-special-file'      => 0, 
    'character-special-file'  => 0, 
    'tty'                     => 0
);
my %file_target_count_by_types = ( 
    'total'                   => 0,
    'non-symlinks'            => 0, 
    'plain-file'              => 0, 
    'symlink'                 => 0, 
    'pipe'                    => 0, 
    'socket'                  => 0, 
    'block-special-file'      => 0, 
    'character-special-file'  => 0, 
    'tty'                     => 0
);

# Read from $in, write to $out as normal.
while(my $line = <$in>) {
    # We later test the type of each file and symlink target. So, we need the correct name of the corresponding path. And for that, we need to convert some XML strings into the characters they actually represent. 
    $line =~ s/&quot;/"/g;
    $line =~ s/&amp;/&/g;
    $line =~ s/&lt;/</g;
    $line =~ s/&gt;/>/g;
    if ($line =~ m/( *)<directory name="(.*)">/)
    {
        $line = "${1}[{\\dirfmt{${2}}}, dir\n";
    }
    elsif ($line =~ m/( *)<\/directory>/)
    {
        $line = "${1}]\n";
    }
    elsif ($line =~ m/( *)<file name="(.*)"><\/file>/)
    {
        $file_target_count_by_types{'non-symlinks'} = $file_target_count_by_types{'non-symlinks'} + 1;

        if (-f $2)
        {
            $file_type = "plain-file"
        }
        elsif (-p $2)
        {
            $file_type = "pipe"
        }
        elsif (-S $2)
        {
            $file_type = "socket"
        }
        elsif (-b $2)
        {
            $file_type = "block-special-file"
        }
        elsif (-c $2)
        {
            $file_type = "character-special-file"
        }
        elsif (-t $2)
        {
            $file_type = "tty"
        }
        elsif (-l $2)
        {
            die("file '$2' is actually a symlink, when tree says it is not?")
        }
        elsif (-d $2) 
        {
            die("file '$2' is actually a directory?")
        }
        elsif (!-e $2)
        {
            die("file '$2' is actually nonexistent?")
        }
        else
        {
            die("symlink target '$2' is not of any recognisable type")
        }
        $file_target_count_by_types{$file_type} = $file_target_count_by_types{$file_type} + 1;
        
        $line = "${1}[{\\filefmt{${file_type}}{${2}}}, file]\n";
    }
    elsif ($line =~ m/( *)<link name="(.*)" target="(.*)"><\/link>/)
    {
        $symlink_target_count_by_types{'total'} = $symlink_target_count_by_types{'total'} + 1;

        if (!-e $3)
        {
            $link_target_type = "nonexistent";
        }
        elsif (-d $3) 
        {
            $link_target_type = "dir";
        }
        elsif (-f $3)
        {
            $link_target_type = "plain-file"
        }
        elsif (-l $3)
        {
            $link_target_type = "symlink"
        }
        elsif (-p $3)
        {
            $link_target_type = "pipe"
        }
        elsif (-S $3)
        {
            $link_target_type = "socket"
        }
        elsif (-b $3)
        {
            $link_target_type = "block-special-file"
        }
        elsif (-c $3)
        {
            $link_target_type = "character-special-file"
        }
        elsif (-t $3)
        {
            $link_target_type = "tty"
        }
        else
        {
            die("symlink target '$3' is not of any recognisable type")
        }
        $symlink_target_count_by_types{$link_target_type} = $symlink_target_count_by_types{$link_target_type} + 1;

        $line = "${1}[{\\symlinkfmt{${link_target_type}}{${2}}{${3}}}, symlink]\n";
    }
    elsif ($line =~ m/<\?xml version=".*" encoding=".*"\?>|<report>|<\/report>/)
    {
        $line = "";
    }
    elsif ($line =~ m/<directories>([0-9]*)<\/directories>/)
    {
        $dir_count = $dir_count + 1;
        $line = "";
    }
    elsif ($line =~ m/<files>([0-9]*)<\/files>/)
    {
        $file_count = $file_count + 1;
        $line = "";
    }
    elsif ($line =~ m/<tree>/)
    {
        $line = "\\begin{forest}\n";
    }
    elsif ($line =~ m/<\/tree>/)
    {
        $line = "\\end{forest}\n";
    }
    else 
    {
        die("Error: a line is of an unexpected form: '$line'.")
    }
    print($out $line);
}
my $report_symlinks = "{\n";
for (keys %symlink_target_count_by_types){
    $report_symlinks .=
<<EOF
            ,$_ = $symlink_target_count_by_types{$_}
EOF
}
$report_symlinks .= "        }";
print($out 
<<EOF
    \\report{
        ,file = $file_count
        ,dir  = $dir_count
        ,symlink = $report_symlinks
    }
EOF
);

# Debug info
    if_debugging(
        sub {
            # Conditionally load the module Text::SimpleTable::AutoWidth to draw tables
                # Source: https://stackoverflow.com/a/62747490/31298396
                eval {
                    require Text::SimpleTable::AutoWidth;
                    Text::SimpleTable::AutoWidth->import();
                    1; 
                } or do {
                my $error = $@;
                # Module load failed. You could recover, try loading
                # an alternate module, die with $error...
                # whatever's appropriate
                };

            print "
    =================
      DEBUG ENABLED
    =================
            \n";
            # Table of various variables
                # Source: https://stackoverflow.com/a/62747490/31298396
            print Text::SimpleTable::AutoWidth
                ->new( captions => [qw/ Variables Value /] )
                ->row( '$textree_target', $textree_target )
                ->draw();
        }
    );