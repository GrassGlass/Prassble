#!/bin/bash
# Flags
    # Source: https://stackoverflow.com/a/7948533/31298396
TEMP=$(getopt -o i:I:O:n:\
              --long "\
                      namestyle:,\
                      ignore:,ignore-add:,ignore-also:,\
                      Ignore:,Ignore-only:,\
                      wsl,WSL,\
                      cygwin,Cygwin,CYGWIN,\
                      debug,
                     "\
              -n 'textree' -- "$@")

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"

# Default values
IGNORE_DEFAULT="FileTrees|_minted|ignore_this*|*.log|*.out|*.tmp|*.synctex(busy)|*.synctex.gz|*.listing|*.pre|*.aux|*.auxlock|*.toc|*.config.minted"
IGNORE_ALSO=
WSL=false
CYGWIN=false
DEBUG=false
NAMESTYLE=name

while true; do
  case "$1" in
    -n | --namestyle ) NAMESTYLE="$2"; shift 2 ;;
    -i | --ignore | --ignore-add | --ignore-also ) IGNORE_ALSO="$2"; shift 2 ;;
    -I | --Ignore | --Ignore-only ) IGNORE_ONLY="$2"; shift 2 ;;
    -O ) OUTPUT_TO="$2"; shift 2 ;;
    --wsl | --WSL ) WSL=true; shift;;
    --cygwin | --Cygwin | --CYGWIN ) CYGWIN=true; shift;;
    --debug ) DEBUG=true; printf "\n =============\n debug mode on\n =============\n"; shift;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

# If $IGNORE_ONLY is undefined, set $IGNORE = $IGNORE_DEFAULT|$IGNORE_ALSO. Or if, simultaneously, $IGNORE_ALSO is empty, set $IGNORE = $IGNORE_DEFAULT (no vertical bar).
if [ -z ${IGNORE_ONLY+x} ]; \
  then \
    if [ -z "${IGNORE_ALSO}" ]; \
      then IGNORE="$IGNORE_DEFAULT"; \
      else IGNORE="$IGNORE_DEFAULT|$IGNORE_ALSO";\
    fi \
  # If $IGNORE_ONLY is defined, set $IGNORE = $IGNORE_ONLY
  else IGNORE="$IGNORE_ONLY"; \
fi

# If $OUTPUT_TO is empty, set $OUTPUT_TO = "filetree.tmp". Otherwise, use its current value.
if [ -z "${OUTPUT_TO}" ]; \
    then OUTPUT_TO="filetree.tmp";\
fi

path_processing () {
    if [ "$WSL" = true ] ; then
        wslpath -u "$1" 
    fi
    if [ "$CYGWIN" = true ] ; then
        cygpath -u "$1" 
    fi
    if [[ "$WSL" == false && "$CYGWIN" == false ]]; then
        cat <<< "$1"
    fi
}

# Processing paths
tree_target="$(path_processing "$1")"
OUTPUT_TO="$(path_processing "$OUTPUT_TO")"

# Process the name to set for the target directory, from the $NAMESTYLE set.
    # $1: $NAMESTYLE
    # $2: $tree_target
case $NAMESTYLE in
    # Case 1: $NAME = name: set $directory_name to be the name of the target directory, instead of $1.
        # Source: https://discord.com/channels/846677253290983444/846681015011115018/1425821608878280794
    name)
        directory_name=$(basename "$(realpath "$tree_target")")
    ;;
    # Case 2: $NAME = realpath: set $directory_name to be realpath $1.
    realpath) 
        directory_name=$(realpath "$tree_target")
    ;;
    # Case 3: $NAME = raw: set $directory_name to be $1.
    raw) 
        directory_name=$tree_target
    ;;
    *) echo "-n NAMESTYLE or --name NAMESTYLE recieved an invalid NAMESTYLE of $NAMESTYLE" || exit ;;
esac
# Escape the replacement string
    # Source: https://stackoverflow.com/a/29613573/31298396
directory_name_escaped=$(sed 's/[&/\]/\\&/g' <<<"$directory_name")

# Escape $1 so it is parsed literally/verbatim in sed's regex.
    # Source: https://stackoverflow.com/a/29613573/31298396
directory_path_escaped=$(sed 's/[^^]/[&]/g; s/\^/\\^/g' <<< "$tree_target") # escape it.
`# Generate the file tree for the directory $1` \
    `# Source: https://tex.stackexchange.com/q/515582/383565` \
tree \
    `# Exclude the folder "some_folder", "another_folder", all files starting with "ignore_this", and all files with extension .log, .out, etc` \
    -I "$IGNORE" \
    `# Print out an XML representation of the tree.` \
    -X \
    `# Turn off file/directory count at end of tree listing.` \
    --noreport \
    `# The directory $1` \
    "$tree_target" \
`# Pass the output of tree to the input of sed` \
| \
`# Text manipulation, for us to convert the XML output format to a TikZ forest one. The option "-e [command]" adds [command] to the list of commands that sed executes. ` \
    `# syntax of the s command: 's/regexp/replacement/flags'` \
sed \
    `# Replace "<directory name=".">" by "<directory name=$directory_name>"` \
    -e "s/<directory name=\".\">/<directory name=\"$directory_name_escaped\">/" \
    `# Replace "<directory name="$1">" by "<directory name=$directory_name_escaped>"` \
    -e "s/<directory name=\"$directory_path_escaped\">/<directory name=\"$directory_name_escaped\">/" \
    `# LaTeX-escape backslashes` \
    -e 's/\\/\\textbackslash/g' \
    `# Replace curly braces in directory/file names by their LaTeX-escaped variants.` \
    -e 's/{/\\{/g' \
    -e 's/}/\\}/g' \
    `# (cont.) LaTeX-escape backslashes` \
    -e 's/\\textbackslash/{\\textbackslash}/g' \
    `# Replace "<tree>" by "\begin{forest}for tree={folder,grow\'=0}/"` \
    -e "s/<tree>/\\\begin{forest}\n file tree,/" \
    `# Replace "</tree>" by "\end{forest}"` \
    -e 's/<\/tree>/\\end{forest}/' \
    `# Replace " target=" by " \symlinkrightarrow"` \
    -e 's/\" target=\"/\" \\symlinkrightarrow \"/' \
    `# Replace "<directory name=" and "<file name=" by an opening square bracket [ (escaped to make it an actual square bracket)` \
    -e 's/<directory name=\|<file name=\|<link name=/[/' \
    `# Replaces "anything that does not contain a double-quotation mark by "` \
            `# backslash \: escapes the character following it.` \
        `# Regex operators` \
            `# \(...\): a capturing group. This simply capture its contents ... as one unit. Think of how curly braces {...} work in LaTeX.` \
            `# \n: contents of the nth capturing group (...).` \
        `# Wildcard operators` \
            `# [...]: a matching list. A character is matched iff it is contained in [...].` \
            `# [^...]: a nonmatching list. A character is matched iff it is not contained in [^...].` \
            `# <string>*: any string that starts with <string>` \
        `# Breakdown` \
            `# \": a double-quote character` \
            `# [^"]: any character that is not a double-quote character` \
            `# [^"]*: any string that does not start with a double-quote character` \
            `# \([^"]*\): same as before` \
            `# \"\([^"]*\)\">: any <string> of the form <string> = "<substring>">, where <substring> (which is just \1) does not contain any double-quote character. ` \
            `# "\([^"]*\)\">/\1: replace any <string> --- of the form <string> = "<substring>">>, where <substring> (which is just \1) does not contain any double-quote character --- by \1 = <substring>` \
            `# "\([^"]*\)\">/\{\1\}: replace any <string> --- of the form <string> = "<substring>">>, where <substring> (which is just \1) does not contain any double-quote character --- by {\1} = {<substring>}` \
                `# Replace "<name>" by "{<name>}" for robustness --- this allows square brackets to be used in directory/file names.` \
    -e 's/\"\([^"]*\)\"[> ]/\{\1\}/g' \
    `# Replace "</directory>", "</file>", and "</link>"  by a closing square bracket "]"` \
    -e 's/<\/directory>\|<\/file>\|<\/link>/]/' \
    `# Delete any string that starts with "<?xml version"` \
    -e '/^<?xml version/d' \
    `# Character replacement to ensure the correct file names are generated.` \
    `# Replace &quot; (which is produced by passing " into sed) by an actual double-quotation mark.` \
    -e 's/&quot;/\"/g' \
    `# Replace characters by their escaped LaTeX counterparts, where necessary.` \
        `# {} and \ have been escaped earlier (for ordering requirements).` \
    -e 's/\$/\\$/g' \
    -e 's/\&amp;/\\\&/g' \
    -e 's/#/\\#/g' \
    -e 's/[|]/{\\textbar}/g' \
    -e 's/_/\\_/g' \
    -e 's/\^/{\\textasciicircum}/g' \
    -e 's/@/\\@/g' \
    -e 's/%/\\%/g' \
    -e 's/\&lt;/{\\textlangle}/g' \
    -e 's/\&gt;/{\\textrangle}/g' \
    -e 's/~/\\textasciitilde/g' \
    -e 's/+/\\(+\\)/g' \
    -e 's/=/\\(=\\)/g' \
    `# Pass the output of sed to the input of install` \
    | \
    `# Create the directory FileTrees and the file tree_$2. if necessary. Then, write the output of sed to tree_$2.` \
        `# Source: https://stackoverflow.com/a/21053077/31298396` \
    install -D /dev/stdin "$OUTPUT_TO"


# --debug: show processed paths
if [ $DEBUG = true ]; then
    # Bolding text
    # Source: https://stackoverflow.com/a/2924755/31298396
    textbf=$(tput bold)
    textrm=$(tput sgr0)
    ulstart=$(tput smul)
    ulend=$(tput rmul)
    textreset=$(tput init)
    textblue=$(tput setaf 4)
    textgreen=$(tput setaf 2)
echo -ne \
"\
${textblue}${textbf}BOOL${textrm}
${textblue}DEBUG:$DEBUG
${textblue}WSL:$WSL
${textblue}CYGWIN:$CYGWIN
${textgreen}${textbf}Strings${textrm}
${textgreen}tree_target:$tree_target
${textgreen}directory_name:$directory_name
${textgreen}directory_name_escaped:$directory_name_escaped
${textgreen}directory_path_escaped:$directory_path_escaped\
${textreset}\
"\
 | \
column -t -s ":" -N "${ulstart}${textbf}VARIABLE,VALUE${textrm}${ulend}"
fi