\documentclass{article}
\usepackage{bashful}
\usepackage[edges]{forest}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}
\newlength\Size
\setlength\Size{4pt}
\tikzset{%
  folder/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
  },
  file/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-4pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
  },
}
\forestset{%
  declare autowrapped toks={pic me}{},
  declare boolean register={pic root},
  pic root=0,
  pic dir tree/.style={%
    for tree={%
      folder,
      font=\sffamily,
      grow'=0,
    },
    before typesetting nodes={%
      for tree={%
        edge label+/.option={pic me},
      },
      if pic root={
        tikz+={
          \pic at ([xshift=\Size].west) {folder};
        },
        align={l}
      }{},
    },
  },
  pic me set/.code n args=2{%
    \forestset{%
      #1/.style={%
        inner xsep=2\Size,
        pic me={pic {#2}},
      }
    }
  },
  ,file tree/.style = {
    ,pic me set={directory}{folder}
    ,pic me set={file}{file}
    ,pic dir tree
    ,pic root
    ,for tree={% folder icons by default; override using file for file icons
      ,directory
      ,fit = band
      ,l sep = 2\Size+2mm
    }
  }
}
\begin{document}
\bash[stdoutFile=mydirtree.tex]
    # Store the name of the PWD as $PWD_name
        # Source: https://stackoverflow.com/a/1371283/31298396
    PWD_name=${PWD##*/}
    PWD_name=${PWD_name:-/}
    `# Generate the file tree` \
        `# Source: https://tex.stackexchange.com/q/515582/383565` \
    tree \
        `# Exclude the folder "some_folder", "another_folder", all files starting with "ignore_this", and all files with extension .log, .out, etc` \
        -I 'some_folder|another_folder|minted|ignore_this*|*.log|*.out|*.synctex(busy)|*.listing|*.pre|*.aux|*.auxlock|*.toc|*.config.minted' \
        `# Print out an XML representation of the tree.` \
        -X \ 
        `# Turn off file/directory count at end of tree listing.` \
        --noreport \
    `# Pass the output of tree to the input of sed` \
    | \
    `# Text manipulation, for us to convert the XML output format to a TikZ forest one. The option "-e [command]" adds [command] to the list of commands that sed executes. ` \
        `# syntax of the s command: 's/regexp/replacement/flags'` \
    sed \
        `# Replace "<directory name=".">" by "<directory name=#PWD_name>"` \
        -e "s/<directory name=\".\">/<directory name=\"$PWD_name\">/" \
        `# Replace "<tree>" by "\begin{forest}for tree={folder,grow\'=0}/"` \
        -e "s/<tree>/\\\begin{forest}\n file tree,/" \
        `# Replace "</tree>" by "\end{forest}"` \
        -e 's/<\/tree>/\\end{forest}/' \
        `# Replace "<directory name=" and "<file name=" by an opening square bracket [ (escaped to make it an actual square bracket)` \
        -e 's/\(<directory name=\)\|\(<file name=\)/[/' \
        `# Replaces "anything that does not contain a double-quotation mark by "` \
                `# backslash \: escapes the character following it.` \
            `# Regex operators` \
                `# \(...\): a capturing group. This simply capture its contents ... as one unit. Think of how curly braces {...} work in LaTeX.` \
                `# \n: contents of the nth capturing group (...).` \
            `# Wildcard operators` \
                `# [...]: a matching list. A character is matched iff it is contained in [...].` \
                `# [^...]: a nonmatching list. A character is matched iff it is not contained in [^...].` \
                `# <string>*: any string that starts with <string>` \
            `# Breakdown` \
                `# \": a double-quote character` \
                `# [^\"]: any character that is not a double-quote character` \
                `# [^\"]*: any string that does not start with a double-quote character` \
                `# \([^\"]*\): same as before` \
                `# \"\([^\"]*\)\">: any <string> of the form <string> = "<substring>">, where <substring> (which is just \1) does not contain any double-quote character. ` \
                `# "\([^\"]*\)\">/\1: replace any <string> --- of the form <string> = "<substring>">>, where <substring> (which is just \1) does not contain any double-quote character --- by \1 = <substring>` \
        -e 's/\"\([^\"]*\)\">/\1/' \
        `# Replace "</directory> by a closing square bracket "]"` \
        -e 's/<\/directory>/]/' \
        `# Replace "</directory> by a closing square bracket "]"` \
        -e 's/<\/file>/, file]/' \
        `# Delete any string that starts with "<?xml version"` \
        -e '/^<?xml version/d' \
        `# Replace the character "_" by its escaped LaTeX counterpart "\_".` \
        -e 's/_/\\_/g'
\END
\input{mydirtree}
\ExplSyntaxOn
\sys_shell_now:n {printf~"hello"~>~bash.tmp}
\ExplSyntaxOff

\end{document}
